
/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

#ifndef __dbusxx__keti_dbus_adaptor_h__ADAPTOR_MARSHAL_H
#define __dbusxx__keti_dbus_adaptor_h__ADAPTOR_MARSHAL_H

#include <dbus-c++/dbus.h>
#include <cassert>

namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class ADC_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    ADC_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.ADC")
    {
        register_method(ADC_adaptor, lightning_sensor_read, _lightning_sensor_read_stub);
        register_method(ADC_adaptor, read_adc_value, _read_adc_value_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument lightning_sensor_read_args[] = 
        {
            { "fru", "y", true },
            { "sensor_num", "y", true },
            { "value", "i", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument read_adc_value_args[] = 
        {
            { "pin", "i", true },
            { "device", "s", true },
            { "value", "i", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod ADC_adaptor_methods[] = 
        {
            { "lightning_sensor_read", lightning_sensor_read_args },
            { "read_adc_value", read_adc_value_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod ADC_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty ADC_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface ADC_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.ADC",
            ADC_adaptor_methods,
            ADC_adaptor_signals,
            ADC_adaptor_properties
        };
        return &ADC_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual int32_t lightning_sensor_read(const uint8_t& fru, const uint8_t& sensor_num) = 0;
    virtual int32_t read_adc_value(const int32_t& pin, const std::string& device) = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _lightning_sensor_read_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        uint8_t argin1; ri >> argin1;
        uint8_t argin2; ri >> argin2;
        int32_t argout1 = lightning_sensor_read(argin1, argin2);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _read_adc_value_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argin1; ri >> argin1;
        std::string argin2; ri >> argin2;
        int32_t argout1 = read_adc_value(argin1, argin2);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } } 
namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class Ibmc_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Ibmc_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.Ibmc")
    {
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedMethod Ibmc_adaptor_methods[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Ibmc_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Ibmc_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Ibmc_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.Ibmc",
            Ibmc_adaptor_methods,
            Ibmc_adaptor_signals,
            Ibmc_adaptor_properties
        };
        return &Ibmc_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
};

} } } } 
namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class FAN_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    FAN_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.FAN")
    {
        register_method(FAN_adaptor, read_fan_value, _read_fan_value_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument read_fan_value_args[] = 
        {
            { "fanno", "i", true },
            { "value", "i", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod FAN_adaptor_methods[] = 
        {
            { "read_fan_value", read_fan_value_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod FAN_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty FAN_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface FAN_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.FAN",
            FAN_adaptor_methods,
            FAN_adaptor_signals,
            FAN_adaptor_properties
        };
        return &FAN_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual int32_t read_fan_value(const int32_t& fanno) = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _read_fan_value_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argin1; ri >> argin1;
        int32_t argout1 = read_fan_value(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } } 
namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class PSU_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    PSU_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.PSU")
    {
        register_method(PSU_adaptor, peci_CPU_TEMP0, _peci_CPU_TEMP0_stub);
        register_method(PSU_adaptor, read_lm75_value, _read_lm75_value_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument peci_CPU_TEMP0_args[] = 
        {
            { "ret", "d", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument read_lm75_value_args[] = 
        {
            { "no", "i", true },
            { "value", "d", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod PSU_adaptor_methods[] = 
        {
            { "peci_CPU_TEMP0", peci_CPU_TEMP0_args },
            { "read_lm75_value", read_lm75_value_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod PSU_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty PSU_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface PSU_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.PSU",
            PSU_adaptor_methods,
            PSU_adaptor_signals,
            PSU_adaptor_properties
        };
        return &PSU_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual double peci_CPU_TEMP0() = 0;
    virtual double read_lm75_value(const int32_t& no) = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _peci_CPU_TEMP0_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        double argout1 = peci_CPU_TEMP0();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _read_lm75_value_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argin1; ri >> argin1;
        double argout1 = read_lm75_value(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } } 
#endif //__dbusxx__keti_dbus_adaptor_h__ADAPTOR_MARSHAL_H
