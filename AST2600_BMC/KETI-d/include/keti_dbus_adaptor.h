
/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

#ifndef __dbusxx__keti_dbus_adaptor_h__ADAPTOR_MARSHAL_H
#define __dbusxx__keti_dbus_adaptor_h__ADAPTOR_MARSHAL_H

#include <dbus-c++-1/dbus-c++/dbus.h>
#include <cassert>
/**
 * @brief DBus ADC Sensor adaptor
 * @details rpc 기능 수행을 위한 서버측 정의 이하 동일
 * 
 */
namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class ADC_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    ADC_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.ADC")
    {
        register_method(ADC_adaptor, lightning_sensor_read, _lightning_sensor_read_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument lightning_sensor_read_args[] = 
        {
            { "fru", "y", true },
            { "sensor_num", "y", true },
            { "value", "i", true },
            { "ret", "i", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod ADC_adaptor_methods[] = 
        {
            { "lightning_sensor_read", lightning_sensor_read_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod ADC_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty ADC_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface ADC_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.ADC",
            ADC_adaptor_methods,
            ADC_adaptor_signals,
            ADC_adaptor_properties
        };
        return &ADC_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual int lightning_sensor_read(uint8_t fru, uint8_t sensor_num,  int *value) = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _lightning_sensor_read_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        uint8_t argin1; ri >> argin1;
        uint8_t argin2; ri >> argin2;
        int32_t argin3; ri >> argin3;
        int argout1 = lightning_sensor_read(argin1, argin2, argin3);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } } 
namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class edge_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    edge_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.edge")
    {
        register_method(edge_adaptor, rpc_test, _rpc_test_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument rpc_test_args[] = 
        {
            { "msg", "s", true },
            { "res", "s", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod edge_adaptor_methods[] = 
        {
            { "rpc_test", rpc_test_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod edge_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty edge_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface edge_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.edge",
            edge_adaptor_methods,
            edge_adaptor_signals,
            edge_adaptor_properties
        };
        return &edge_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual std::string rpc_test(const std::string& msg) = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _rpc_test_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        std::string argout1 = rpc_test(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } } 
namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class FAN_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    FAN_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.FAN")
    {
        register_method(FAN_adaptor, read_fan_value, _read_fan_value_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument read_fan_value_args[] = 
        {
            { "fanno", "i", true },
            { "value", "i", true },
            { "ret", "i", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod FAN_adaptor_methods[] = 
        {
            { "read_fan_value", read_fan_value_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod FAN_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty FAN_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface FAN_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.FAN",
            FAN_adaptor_methods,
            FAN_adaptor_signals,
            FAN_adaptor_properties
        };
        return &FAN_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual int read_fan_value( int fanno,  int *value) = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _read_fan_value_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argin1; ri >> argin1;
        int32_t argin2; ri >> argin2;
        int32_t argout1 = read_fan_value(argin1, argin2);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } } 
namespace org {
namespace freedesktop {
namespace keti {
namespace bmc {

class PSU_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    PSU_adaptor()
    : ::DBus::InterfaceAdaptor("org.freedesktop.keti.bmc.PSU")
    {
        register_method(PSU_adaptor, read_psu_value, _read_psu_value_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument read_psu_value_args[] = 
        {
            { "device", "c", true },
            { "addr", "y", true },
            { "type", "y", true },
            { "value", "i", true },
            { "ret", "i", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod PSU_adaptor_methods[] = 
        {
            { "read_psu_value", read_psu_value_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod PSU_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty PSU_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface PSU_adaptor_interface = 
        {
            "org.freedesktop.keti.bmc.PSU",
            PSU_adaptor_methods,
            PSU_adaptor_signals,
            PSU_adaptor_properties
        };
        return &PSU_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual int32_t read_psu_value(const std::string device, const uint8_t addr, const uint8_t type,  int *value) = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _read_psu_value_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        uint8_t argin2; ri >> argin2;
        uint8_t argin3; ri >> argin3;
        int32_t argin4; ri >> argin4;
        int32_t argout1 = read_psu_value(argin1, argin2, argin3, argin4);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } } } 
#endif //__dbusxx__keti_dbus_adaptor_h__ADAPTOR_MARSHAL_H
